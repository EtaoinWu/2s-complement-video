== Two’s Complement Script ==

Two’s complement, is how computers represent negative integers. You might know that computers store bits, but numbers are not just bits, and two’s complement is the way we handle negative integers. I believe it’s one of the most mistaught concept in computer science courses. You always hear people talk about one’s complement and do this weird “plus one” trick, and you might wonder how could people ever think of doing this. If you were frustrated like me, this video is for you.

Imagine we are in an alternative universe. It is the Christmas of 1968, and your dad just bought you a pocket calculator. Since we are so far back into computer history, the calculator is kinda terrible, and it can only operate on 2 digit numbers, so from zero zero to ninety-nine. It also offers a limited selection of operations: only 2 of them,  addition and multiplication. Honestly, not very useful; but it can still tell you that twelve times seven is eighty-four. But what if the result is larger than a hundred? Out of curiosity, you tried twelve times twelve, and got forty-four. Ehh, what?

It turns out, that this calculator is lazy. If a result has more digits than supported, they are ignored, chopped off, and only the last two digits are shown. The calculator can only display two numbers, and it refuses to show more. So, in the lazy brain of our calculator, twelve by twelve is equal to forty-four. We will write a “lazy” above the equal sign to denote this. If we try twenty-eight by twenty-three, the lazy calculator thinks that the result is also equal to forty-four.

So, in the calculator’s eye, twelve by twelve is equal to twenty-eight by twenty-three, but we clearly see that they are different – they differ by 500, in fact. You see, the lazy calculator considers two numbers equal if they differ by a multiple of a hundred. This is because when you chop off some digits to keep the last two, you always chop off a multiple of one hundred.

Next morning, you want to find out how many weeks there are in a 31-day month. A week is 7 days, so you want to calculate 31 divided by 7. Since you just got this fancy little box yesterday, you naturally want to use it, but sadly it cannot do division, so you thought of an old method: subtracting repeatedly. You see, 31 days minus one week is 24 days, minus another week is 17 days, minus another, 10, and then it’s 3 days. 3 is less than 7, so our original 31 days is 4 weeks and then some. However, you just realized that your calculator cannot do subtraction as well. You read the manual of the calculator, which said: “try adding 93 to stuff and see what happens!” Desperate, you turned the calculator on, entered your number 31, and added 93. The number that popped up is 24. And then you added 93 again, and got 17. Same thing, and 10, and then eventually also 3.

But why could you subtracting 7 by adding 93? You see, every time we add 93 to these numbers, we actually got something slightly larger than a hundred, and we chopped off the 1 on the left. We basically added 93 and then subtracted 100, and the net result is just subtracting 7. So, for this purpose, we can say that 93 is basically negative 7. In the same way, 94 is negative 6, 95 is negative 5, and so on and so forth, and 99 is negative 1. 

Then you realized that the calculator has another operation, multiplication. Would our newly discovered negative numbers also work in multiplication as well? You then tried it. What’s negative 1 by negative 1? If we do ninety-nine by ninety-nine, it is lazily equal to one. What’s “negative” 2 by 3? You entered ninety-eight by three, and the screen reads ninety-four, which we know is negative six. 

In general, if we multiply two “negative” numbers together, let’s say negative x by negative y. In the calculator, we will enter [a hundred minus x] times [a hundred minus y]. It will be a hundred squared, plus a hundred times [x plus y], minus x times y. These first two terms are multiples of a hundred, so they get wiped out by the calculator, and only xy remains.

We earlier said that, if two numbers differ by a multiple of 100, the calculator will think they are the same. We have just extended this to negative numbers as well, and we showed that this works with addition and multiplication. Mathematically, this structure is called integers “modulo” 100, or “mod” 100, and no matter what you mod, addition and multiplication is preserved, for positive and negative numbers. Mathematicians use the Z symbol for integers, the slash symbol for “modulo”, and “integer mod 100” is written as Z⁄100Z. For the “lazy equality”, mathematicians use this symbol, pronounced “equivalent to”. If we list all the integers mod 100, we will start from 0, 1, 2, go all the way to 99, 100 which is 0, and then 1 again. The numbers loop back to themselves, like a circle or a ring. In abstract algebra this kind of structure is therefore called a ring.

As a convention, people give names to these numbers. We started calling the “smaller” numbers 1, 2, 3, and the “largest” numbers minus 1, minus 2, minus 3, and so on. We split the numbers down the middle. Positive gets one half, negative gets one half. If we look at the other end of the circle, 49 will be just 49, 51 will be negative 49, but what’s 50? You decided that 50 is named “negative 50”. Why? This will make it easy to tell whether a number is negative. You just look at the highest digit. Five through nine? Negative. Zero through four? Positive or 0. It’s important to know that this system of giving names to numbers is just a convention – For the lazy calculator, it doesn’t matter if the number goes by 93 or negative 7; it does the calculation anyways. Calling a number by a different name doesn’t change how it behaves.

There’s one more hack. How do we find the negative of a number? Mathematically, we just subtract it from 100. But that’s going to be a lot of borrowing, and we hate subtraction with borrowing. The hack is like this: 100 is just 99 plus 1. So, 100-x=(99-x)+1. Subtraction from 99 is very easy; you can do this digit-by-digit and don’t need to worry about borrowing at all; we can then add 1 to it, so the negative of 42 is 57 plus 1, or 58.

In hypothetical story, everything happens in decimal. In the real world, this process happened with binary. Early CPUs are really simple – they are just binary calculators with addition and multiplication. Many of them are 8 digits, so the numbers range from 00000000 to 11111111 in binary. Usually we refer to them as 0 to 255, called the unsigned representation of these numbers. Just like us with the calculator, early computer scientists were trying to find a way to calculate on negative numbers, and figured out the same thing as we have done before. They assigned half of the numbers to be 0 through 127, and the upper half to be negative 128 to negative 1. Again, addition and multiplication works nicely with these names. In our decimal system, the highest digit will serve as both the ten place and the sign. Now in binary, the highest bit represents sign only, so it’s called the sign bit.

Now, how do we get the negative of a number? In decimal, we subtract the number from 99, and then add 1. In binary, the role of 99 is replaced with the string of all 1s, the largest number. So, we take the “all one” number minus x. That is visually just flipping every bit – zeros become ones, ones become zeros. That’s the easy part. But just like in decimal, we are short by one. So, we add the 1 back in. Flip the bits. Add one. It’s not magic. It’s just 100−x in disguise. For historical reasons, this system is known as “two’s complement”, but for me, it’s just the most natural way to do positive and negative arithmetic on a calculator. Or on a CPU.

Thank you very much for watching.
